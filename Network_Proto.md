# QUIC协议

## 基本知识

``` shell

    1.RTT(Round Trip Time):表示客户端从发出一个请求数据,到接收到响应数据之间间隔的时间.
        影响RTT由两部分构成：
            (1):物理条件的限制,间隔距离除以信号传递速度,以及包大小除以带宽
            (2):中间软件的解析时间,客户端、服务器以及沿途各路由器对包的处理解析时间
    2.QUIC协议（Quick UDP Internet Connections）是一个完全构筑在UDP而不是TCP之上的Web协议

```

## QUIC 协议特点

### 多路复用，避免队头阻塞

``` shell
    现请求一个网页平均涉及到 80 个资源,30多个域名.考虑最原始的情况,每请求一个资源都需要建立一次 TCP 请求,显然不可接受.
    HTTP 协议规定了一个字段 Connection，不过默认的值是close(不开启),HTTP 1.1协议中就把Connection的默认值改成了Keep-Alive,
    这样同一个域名下的多个 HTTP 请求就可以复用同一个 TCP 连接。这种做法被称为 HTTP Pipeline，优点是显著的减少了建立连接的次数，
    也就是大幅度减少了 RTT.
    
```

# kcp协议

## 简介

``` shell
    kcp只是一个算法上的实现,力求在保证可靠性的情况下提高传输速度,协议的关注点主要在控制数据的可靠性和提高传输速度上面,
    并没有规定下层传输协议,一般用udp.因为kcp采用的拥塞控制,slow start, 快速重传,选择性重传等这些算法都像是
    对tcp协议类似算法一个相对简单的实现.
    kcp层协议的数据包在udp数据报文的基础上增加控制头.当用户数据很大,大于一个udp包能承担的范围时（大于mss）,
    kcp会将用户数据分片存储在多个kcp包中.因此每个kcp包称为一个分片.
    
```

## kcp重传机制

``` shell

    停等的重传机制:
        为实现重传机制,kcp为每个分片(udp包)分配一个唯一标识,接收方收到一个包后告知 发送方　收到的包的序号, 发送方接到确认后再继续发送。
        而如果发送方在一定时间内（超时重传时间）没有接到确认,就说明数据包丢失了,发送方需要重传丢失的数据包,
        所以发送方会把待确认的数据缓存起来方便重传.
        
    滑动窗口机制:
        为了解决停等的重传机制（需要得一个包一个包阻塞等待确认)问题,如果发送方发送多个包出去,然后等待接收方一一确认,
        又由于接收方不可能同时处理无限多的数据,因此需要限制发送方往网络中发送的数据数量,因此接收方限制 发送方在未收到确认之前只能发送
        wnd大小的数据.这个机制叫做滑动窗口机制
        
    超时重传机制
        当网络拥堵严重时,会发生丢包,丢包发生时kcp为了保证可靠性需要重传数据.而发送方需要判断什么时候发生了丢包,以及丢了哪些包.
        为了解决这个问题,发送方为缓存队列中的每个包设置了包序号和超时重传时间.当检测到当前时间超过了分片的超时重传时间,
        该分片还没有得到确认时就会触发该分片的超时重传.
        
    选择性重传机制：
        丢包发生时,由于滑动窗口的存在,假设第n个包丢失了,但是此时n+1，n+2号包却已经传输成功了，此时最好只重传丢失的n号包，
        而不重传成功传输的n+1，n+2号包,这个机制叫做选择重传,选择重传的关键在于接收方要告知发送方哪些包已经收到了，哪些包没有收到，
        为了最小化数据量，接收方可以告诉发送方哪些包已经按序收到了，哪些包是收到的但是不连续。所以返回的ack中包含rcv_nxt和sn。
        rcv_nxt代表收到的所有连续的包，sn代表哪些不连续的包收到了，那么根据这两个参数可以计算出来没有收到的包的序号.
        
    快速重传机制:
        数据在网络中的传输时间是不固定的,因此超时重传时间比较长.而为了尽早地判断出数据包的丢失，kcp引入了快速重传机制。
        快速重传机制工作原理是,当发送方发送了n,n+1,n+2...等等包出去后，接收方没有接收到n,而接收到n+1,n+2..等等n号包之后的包，
        这时因为n号包之后的包都已经接收到了，而n号包还没有接收到，所以可以认为n号包已经丢失了,告知发送方可以进行快速重传。
        kcp为了支持快速重传，接收方需要告诉发送方，哪些包已经成功收到了，哪些包没有收到。因此接收方返回发送方的确认数据（ack）中
        包含以下信息：接收窗口左端的序号rcv_nxt,接收到的大于rcv_nxt的包序号sn。rcv_nxt的含义是接收方已经成功按顺序接收了
        rcv_nxt序号之前的所有包,大于rcv_nxt的序号sn表示的是在接收窗口内的不连续的包。发送方接收到接收方发过来的数据时，
        首先解析rcv_nxt，把发送缓存中所有小于rcv_nxt序号的包全部移除掉（因为这些包全都都已经正确接收了）。然后再解析sn,遍历发送缓存，
        找到所有序号小于sn的包，这些包就是可能在网络中已经丢掉了的包,只是可能，因为有可能这些包只是拥堵在了网络中，需要更长的时间到达，
        所以这里我们设置一个快速重传的门限，对每个分片维护一个快速重传的计数，每收到一个ack解析sn后找到了一个分片，
        就把该分片的快速重传的计数加一，如果该计数达到了快速重传门限，那么就认为该分片已经丢失，可以触发快速重传，
        发送端发送了1,2,3,4,5几个包，然后收到远端的ACK: 1, 3, 4, 5，当收到ACK3时，KCP知道2被跳过1次，收到ACK4时，知道2被跳过了2次,
        此时可以认为2号丢失，不用等超时，直接重传2号包，大大改善了丢包时的传输速度。
        该门限值在kcp中可以设置，tcp中是3.
        
    拥塞控制(拥塞窗口):
        让网络充分被利用,但是不能堵塞,这里引入了慢启动机制,慢启动也就是控制拥塞窗口从0开始增长，随着数据不断地成功传输，拥塞窗口逐渐增大,
        直至达到饱和,也就是网络的收发平衡。为了快速达到网络的收发平衡,拥塞窗口采用倍数增长。也就是每成功发送一个数据 拥塞窗口*2，
        举个例子，窗口大小为1时，发送一个数据，成功后窗口变成2，之后发送两个数据出去，成功接收后窗口大小变为4。
        为了方便让更多的用户连入网络时，网络能有足够的流量提供给用户，还可以设置拥塞门限，拥塞门限值就是当用户拥塞窗口快速增长到门限值后就
        减慢增加速度，缓慢增长，腾出流量给其它用户。
        但是当网络很拥堵的情况下,导致发送数据出现重传时，这时说明网络中消息太多了，用户应该减少发送的数据，也就是拥塞窗口应该减小。
        怎么减小呢，在快速重传的情况下，有包丢失了但是有后续的包收到了，说明网络还是通的，这时采取拥塞窗口的退半避让,拥塞窗口减半，
        拥塞门限减半。减小网络流量，缓解拥堵。当出现超时重传的时候，说明网络很可能死掉了，因为超时重传会出现，原因是有包丢失了，
        并且该包之后的包也没有收到，这很有可能是网络死了，这时候，拥塞窗口直接变为1，不再发送新的数据，直到丢失的包传输成功。
    
```

- Kcp 发送模式

``` shell

    1.stream模式　: stream把一个周期内的小包拼到一个切片的大小发送,
    2.packge模式 :packet把每个小包都直接发送

    
```

[参考资料](http://blog.csdn.net/dxpqxb/article/details/77253297)

## 程序使用

``` shell

    1.设置回调函数
        void ikcp_setoutput(ikcpcb *kcp, int (*output)(const char *buf, int len, 
            ikcpcb *kcp, void *user)).
            
    2.发送应用程序的数据
        int ikcp_send(ikcpcb *kcp, const char *buffer, int len)
    
```

## 使用流程

``` shell

    1.发送数据流程
        先调ikcp_send函数,传入用户数据,ikcp_send函数会调用初始化kcp时的回调函数(kcp1->output = udp_output),而回调函数实现了
        将实际数据发送到网络上(udp中sendto)
        
    2.
        
    
```