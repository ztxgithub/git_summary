# 数据密集型处理系统

## 数据密集系统问题
```shell
    (1) 当出现局部性失效时，如何保证数据完整性和一致性
    (2)负载增加时，如何扩展？
    (3) 如何设计友好的对外 api 接口
```

## 基础知识
```shell
    (1) 描述系统性能，指标有响应时间的百分位数
    (2) 描述负载，参数选择取决于系统的结构，例如 web 服务器则采用每秒请求处理次数。数据库则采用写入的比例。
        缓存命中率
    (3)「响应时间」是指针对客户端而言的，包括请求处理，网络延迟，队列延迟。而「延迟」只是请求处理。
    (4) 数据库中保存地区（region_id），产业（industry_id），一般采用 id 而不是纯文本字符串。前端界面可以用下拉框选择，
        而不是用户输入。好处：1. 保存的形式统一，规范。2. 易于更新，如果有业务场景需要修改地区等信息，只需要修改一处。
        3. 更好的搜索支持。像这种用 id （用户不关心的信息）来代表其标识的信息主要是保持数据一致性，
        防止标识的信息在各个地方重复保存，在以后更新时需全部替换。
    (5) MapReduce 主要用于分布式系统
    (6) 图状模型的应用。 1. 社交网络。 2. web 图，PageRank 计算 web 网页上的流行度来推算搜索排名。 
                       3. 公路网，导航中计算两点之间的最短路径。
    (7) LSM存储引擎（log structure Merge），基于合并和压缩排序文件原理的存储引擎。
    (8) 索引值的形式，「第一种」直接存储实际行的数据，例如聚集索引。「第二种」对其他的引用，其通过额外的跳转会取到数据。
        例如非聚集索引。在聚集索引和非聚集索引之间折中实现是"覆盖索引"，它不会保留整个行的数据，只会保留这个行中某些列的数据。
        联合索引（多级索引）例如（first_index, second_index）,
        可以查询 first_index = 特定值1 && second_index = 特定值2 的所有记录，
        也可以查询（特定值1在某一范围 && 特定值 = 某一个值，不过 second_index 索引失效了）。
        但这个联合索引无法查询（特定值1在某一范围&&特定值2在某一范围）
    (9) 事务是指一个逻辑单位的一组读写操作。
```

## 技巧
```shell
    1. 当一个表中的 1 列需要拆解为 2 列，如果在大表进行 update 操作慢不接受，可以先将目标列初始化为 NULL，在查询时在判断填充。
```

## 认识数据系统
```shell
    1. 数据密集型系统包含数据库模块，高速缓存模块，索引，流式处理（持续发送消息到另一个进程，异步方式），
       批处理（定期处理大批量累计的数据）
    2. 数据系统的核心目标，可靠性，可扩展性，可维护性。
            (1) 可靠性，即使发生某些错误，系统仍然可以继续工作，容错只是针对某一类型的错误。设计容错机制防止从「故障」到
                系统「失效」，系统失效则意味着系统整体停止，无法对外提供服务。针对硬件故障（硬盘故障，内存故障），
                可以采用硬件冗余。级联故障（一个小组件故障导致另一个组件故障，进而引发更多故障）
            (2) 可扩展性，由于负载的增加导致现有的可靠性降低。对应可扩展性，应该考虑的是系统负载增加了，应该采用各种扩展方式？
                如何添加计算机资源来应对额外的资源？在所有请求的数据量都相同的情况下，其响应时间也会有差异，
                可能是因为一些因素产生随机抖动。如上下文切换，进程调度，网络数据包丢失，TCP 超时重传，磁盘 IO，缺页中断。
                对应描述响应时间，采用百分位数比较合适，如 p50，p99（将响应时间按递增方式排序，其 50%位置，其 99% 位置）。
                扩展方式有垂直扩展（升级更强大的机器）和水平扩展（分布到更多小机器）。设计一个分布式系统背后考虑因素有数据读取量，
                数据写入量，预存储数据量，数据复杂程度，响应时间，访问模式。可扩展架构往往通常从通用模块构建来的。
            (3) 可维护性，这涉及到软件系统的三个设计原则：
                    1. 可运维性，良好规范的可操作性，包括提供系统运行时的监控，支持自动化，提供良好默认的配置。
                    2. 简单性，简单复杂化，消除意外性复杂的方式是抽象，其隐藏内部复杂的实现，而对外提供简单，干净的接口 
                    3. 可演化性，在简单性的基础上，针对新的需求易于修改

```
## 数据模型与查询语言
```shell
    1. 基于 API 来构建上层 API，其中心思想是每一层都通过简洁的数据模型隐藏下层的复杂性。
    2. NoSQL（不仅仅 SQL），其优点是比 SQL 更易于扩展，支持超大数据集成或者超高写入吞吐量。大多数 NoSQL 支持开源，
       关系模型不能很好支持特定查询语句。例如一对多的关系，例如简历，一个用户可能对应多个教育背景，工作背景，联系方式。
       这样如果用关系模型话需要建立更多的表，查询要复杂一点。如果用 json 等数据模型，可以用 mongodb 等支持该数据模型的数据库。
    3. 关系数据库可以有联结的操作，防止冗余
    4. 关系模型最核心的模块是查询优化器，使得增加新的查询方式变得简单，只需要增加索引即可。查询优化器会自动挑选出最优的方式。
    5. 文档数据库特点是模式灵活，其局部性带来高性能，更接近与应用程序使用的数据模型。而关系型数据库则强在联结，在多对一，
       多对多上表达更简洁。
    6. 使用哪种数据模型取决于应用场景，在应用程序需要类似文档结构（一对多）的情况，「文档模型」比较合适，
       关系模型更多的是将数据分解为各个表。文档模型不支持直接引用文档中嵌套项。在关系模型的背景下如果有多对一或则多对多的情况，
       则需要应用程序通过反规范化来减少联结，这样势必导致应用程序要维护非规范化数据的一致性，这样导致应用程序更复杂，性能差。
       所以在多对多的情况下使用「关系模型」比较合适。同时多对多的情况「图状数据模型」也比较合适。图状数据模型更容易适应业务的发展，
       数据结构的变化，两个顶点可以代表相同的事物，也可以代表不同事物，只需要将边的标签类型设置不同即可。
       文档数据库适应与程序频繁访问整个文档内容，而不是访问文档中一小部分内容。其局限性是数据库通常会将整个文档加载进来，
       如果只访问部分就有点浪费，同时更新到数据库时也是整个文档覆盖。性能方面是其文档大小尽量小并且更新时增加文档大小。
    7. 数据查询语言。
            (1). 声明式语言（SQL），只需要指定所需的数据模式，结果满足什么条件，如何转化数据（聚合，排序），而不需要如何实现。
                 其隐藏了数据库的很对细节，同时其不保证特定的顺序，所以比较合适并行执行。
            (2). 命令式语言。告诉计算机以特定的顺序执行某个操作，其很难进行并行执行。

```

## 数据存储和检索
```shell
    1. 从数据库的角度探讨如何存储输入的数据，并在收到查询请求时，如何重新找到数据。
    2. 两大存储引擎，1. 日志结构的存储引擎。哈希表和 SSTable 2. 面向页的存储引擎。B-tree 存储引擎，一般是 4 KB
    3. 在数据库中，日志是一个仅支持追加式更新的数据文件（记录序列的集合），其内容可以是二进制数据。
    4. 为了能更高效得在数据库中找到特定的值，采用索引方式，但其同时造成了写数据的成本，需要维护索引。
    5. 哈希表，主要的数据存储是通过 key-value,其中 value 代表保存在文件的偏移量，在文件中保存的内容可以是 csv 的形式
      （例如 42, "value_string"/n），数据的保存是以追加写的方式，相比于新值更新旧值而已，追加效率更高，顺序写要比随机访问效率高。
       防止一个文件写满磁盘，采用合并压缩各个段，因为是追加更新，所以前面相同 key 可以删除。
       [哈希表索引的局限性]：1. 哈希表必须全部存到内存中，如果 key 太多，则占用内存和哈希冲突。如果存到磁盘，
                             则需考虑随机访问的效率。
                          2. 区间查询效率不高。
    6. SSTable（排序字符表），各个段内的 key 按顺序排列，这样可以适用于范围查找，并且缩小查找范围。
      「具体流程」：可以现在内存中建一个 key-value 的 avl 树（或者红黑树），这样保证 key 键按顺序排列，
      当内存超过一定熟练时，将其作为 SSTable 表存到磁盘中，因为已经排好序了，所以保存高效。往后程序定期将各个 SSTable 进行合并。
      当有请求来查询时，先查内存 avl ，再查最新的 SSTable，再查次行的 SSTable。
      「问题」：当数据库崩溃时，在内存中的 avl 数据丢失。
      「解决方案」：每次在内存中写入追加到日志中，崩溃恢复，同时内存数据作为 SSTable 保存到磁盘中时，删除日志中相应的值。
      「实际应用」LevelDB, RocksDB。
      「性能优化」查找不存在的 key 效率很慢，如果内存表中没有，最后需要遍历所以在磁盘的 SSTable。
      　　　　　　这时可以采用"布隆过滤器"（内存高效的数据结构，近似计算集合内容，很快得出结果）
    7. B-tree 存储引擎，采用的是固定大小（4 KB）方式存储数据，在顶层页中包含 key 以及页引用，比如当查询的 key 值小于 key1 时，
       通过页引用1，找到对应的子页进行进行树查找。新增或者删除 key，需要再平衡树的高度。
      「稳定性异常」当插入数据导致页溢出（一个页分裂成两个页），在完成部分页写入时崩溃，则可能会产生索引破坏，会有页没有被引用。
      「解决方案」需要预写日志（write-ahead log WAL)这是一个追加修改的文件，每个 B-tree 的修改必须先更新 WAL 
                然后再修改树本身的页。当数据库在崩溃后需要恢复时，该日志用于将 B-tree 恢复到最近一致的状态。
    8. LSM-tree 和 B-tree 区别，LSM-tree 写入性能更高，B-tree 读取内容性能更高。B-tree 写入操作必须写 2 次数据，
       一次是预写日志（崩溃时恢复），一次是页写入（还可能页分裂）。LSM-tree 可以支持更好的压缩，较小碎片，因为文件合并，
       而 B-tree 以固定大小的页为单位，当页被分裂或者一行记录无法适合页时，页中某些空间无法使用。
       B-tree 在存储中键是唯一的，而日志结构存储引擎则会存在不同段中相同的键，那么对于范围查找以及事务 B-tree 更具优势，
       因为事务隔离通过键范围上的锁实现的。
       「LSM-tree（日志结构存储引擎）」 缺点主要体现在压缩过程中出现的问题，第一：压缩过程必然涉及到磁盘操作，
       但磁盘的并发资源有限，所以在压缩过程中很容易读写请求等待的情况。第二：如果写入的吞吐量很高，但压缩并没有仔细配置，
       导致压缩的速度小于写入的速度，则磁盘终将被占满。
    9. 全文搜索和模糊索引，全文搜索支持对一个单词的变体查询。
    10. OLTP（online transaction process 在线事务处理）主要以交互的形式，查询少量的记录。
        OLAP（online analytic process 在线分析处理），主要对数据库大量记录进行分析，主要针对内部分析师。
    11. 大公司由于有很多的系统，其各个系统独立且对应与不同的数据库，并且需要高可用，低延迟，所以不可能让分析员直接在 OLTP 上进行数据分析，
        这样会影响其他数据查询。所以"数据仓库"就产生了，将数据导入到数据仓库
        （提取 - 转换 - 加载，extract - transform - load）ETL 过程。这样分析人员可以在数据仓库中分析，
        并且设计特定存储引擎来进行分析。
    12. 数据仓库的存储模式是星型模式，通常有一张事实表（中心表），该表有几百列，其中很多列都指向维度表的外键。
        对于数据仓库常用列存储，根据每一列中可能存在相同的值，可以采用位图方式。列查询通过第一顺序（索引），列写入通过 LSM-Tree 表

```

## 数据编码及演化
### 数据编码格式
```shell
    1. 在系统迭代过程中，数据格式可能发生变化，与之对应的是新的系统产生，但在部署过程中，会存在新旧系统并存情况，
       所以这个系统需要保存双向兼容。"向后兼容"：较新的代码兼容旧的数据格式。"向前兼容"：较旧的代码兼容新的数据格式。
       这样数据格式很重要，常见的有 xml，json, protobuf , Thrift.
    2. 编码（序列化）：内存中数据结构转化为文件（网络传输）的序列格式。解码（反序列化）过程则相反。
    3. 使用编码语言内置的编解码。「优点」：使用方便。
            「缺点」：(1). 与编译语言强绑定，其他语言无法解析。
                    (2). 存在安全性问题，因为解码时，需要实例化对象，那么攻击者可以让程序解码任意字节序列，这样达到远程执行代码。
                    (3). 忽略多版本数据的兼容。
    4. 二进制编码，由于 json 格式占用空间可能较大，所以采用二进制编码用以支持 json（像MessagePack，Bson，Bjson），
       和 xml（WBXML）。其中二进制编码中各个字段都有其含义。其中 MessagePack 是按照 json 的字段分布，再通过二进制来编码，
       其中包含字段名和字段值。
    5. Thrift（二进制编码），它是由 facebook 开发的，Protocol Buffer 则是有 google 开发的，它们都需要模式来编码数据，
       也就是说数据按照模式来定义各个字段的含义分布，同时它们有其代码生成工具，能够为各个不同的语言生成各自的类，
       应用程序再根据类进行编解码（序列化）。Thrift 的 CompactProtocol 编码格式 与 protocol buffer 数据分布一样，
       即一个字节中包含字段类型和标签号，如果字段类型为整型，对应的值占的空间是可变的，主要通过字节的最高位是否为 1 来判断是否有
       下一个字节。如果模式中字段设置为 required，则该字段数据必须填满，要不然序列化失败，这对捕获异常有用。
    6. 在模式变化（字段增加，删除）下，Thrift 和 Protocol Buffer 是如何保存向后兼容和向前兼容，首先模式中每个字段对应的标签号很重要，
      可以更改字段名，但不能更改标签号（1,2,3），如果是新增字段情况，需要在原有的标签号基础上 + 1，这样可以保证向前兼容，
      即旧的代码拿到新的数据后，对应不能识别的标签号直接忽略。为了保证向后兼容，新增的字段属性一定为 option （可选），
      即新代码拿到旧数据后因为是可选属性，所以没有改字段也没有关系。
    7. Thrift 和 Protocol Buffer 依赖于代码生成，在定义模式之后，可以选择指定的编程语言生成此模式的代码，
       例如  C++ , java 等静态语言，其有个缺点，只有当 Thrift 编码数据解析完后数据才人类可读．
       Avro 编码则适用于动态语言。
    8. 数据传输（数据编码）中可以用 json, xml 等文本格式，也可以用基于模式的二进制方式。
    9. 基于模式的二进制编码的优点
            (1). 该模式相对于 json 数据更加紧凑，其是用标签号来代替字段名。 
            (2). 本身模式是一种可视化的文档，而且是最新的，而不需要外部维护文档。 
            (3). 在模式演化中支持向前兼容和向后兼容。
            (4). 对于静态编程语言，根据模式生成代码，在编译时会进行检查。
```
### 数据流模式
```shell
    1. 基于数据库的数据流
            不同的进程对数据库进行写操作（相当于数据的编码），而不同的进程对数据库进行读操作（相当于数据的解码），
            同时这些进程中模式的版本不同，所以该数据库具备向前兼容，向后兼容。要考虑一种情况就是新的模式（增加某个字段）程序写到数据库时，
            旧模式从数据库读该记录进行反序列化对应的数据模型，再更新到数据库则会存在新的数据字段的缺失。
            「归档存储」有时数据库进行快照，用于备份和加载到数据仓库，则可以将数据库中的不同版本的数据编码为同一的版本（像 Avro 对象容器）
    2. 基于服务的数据流（REST, RPC）
            (0) 其中一个进程通过网络向另一个进程发送请求，并期望尽快得到响应
            (1) 在微服务体系中，各个服务相互独立，同时客户端与服务端使用的数据编码也必须符合向后兼容和向前兼容。
                (可能不同服务提供的 api 版本不同，而客户端构造的请求数据也不同)
            (2)「网络服务」2 种 web 服务，第一种 REST ，其基于 HTTP 设计理念，使用 URL 来标识资源。
                根据 REST 原则设计的 API 为 RESTful。第二种 SOAP，SOAP 是基于 xml 协议的，SOAP web 服务使用的 api
                用 WSDL（web services Description Languages）描述。WSDL 支持代码生成，客户端使用本地类和方法调用远程服务
               （主要是通过编码为 xml, 再由框架进行解码）。soap 服务缺点：1. 编码设计格式可读性查。
                2. 消息过于复杂，严重依赖工具代码生成，支持的编程语言少。
                    a. RESTful API 的优点：有利于实验和调试(只需要使用 web 浏览器或则 curl 工具进行请求就能得到结果，方便调试，
                    　　不需要任何代码生成或则软件安装), 支持所有主流的编程语言和平台，并且有一个庞大的工具生态系统
                       (服务器、缓存、负载均衡器、代理、防火墙、监控、调试工具、测试工具等）
                    b. RPC 则主要侧重与同一组织内多项服务的网络请求，一般在同一数据中心内．
            (3) RPC 与本地函数调用的区别
                    a. 本地函数调用是可预测的，其调用结果与传入参数有关，而 RPC 则不可预测，可能是网络问题，导致请求或则
                    　　响应消息丢失，或则是远程的服务不可用．
                    b. 由于网络原因导致响应消息未收到，进行不断重试，实际上操作已经成功完成，那么就会出现重复进行相同的
                    　　操作，那么远端的操作具备幂等性．本地调用则没有这个问题
                    c. 调用本地函数执行的时间大体都是一致的，而 RPC 调用则依赖与网络延迟
                    d. 调用本地函数时，可以高效将本地的内存的对象通过引用(指针)传入. 而网络请求则需要将这些参数进行序列化发送
                    　　到网络中．
            (3) RPC 的演化
                    由于服务的提供者无法控制客户端，也无法强制升级，所以服务端需要兼容很多版本的 API, 
                    关于 API 版本管理（即客户端拿到想要哪个 API 版本) 对于 RESTful API , 是在 URL 或 HTTP Accept
                    头中使用版本号。对于使用 API 密钥来标识特定客户端的服务，另一种选择是将客户端请求的
                    API 版本存储在服务器上，并允许通过单独的管理接口更新该版本选项
    3. 基于消息传递的数据流
            (1) 消息中间件（消息代理）
                与 RPC 的相比，消息中间件的优点
                    a. 当接收方不可用或过载，充当缓冲区(暂存消息)，提高系统的可靠性。
                    b. 可以将消息重新发送到崩溃的进程中，防止消息丢失.
                    c. 可以对外提供统一的 ip 和 port, 不需要关心实际部署位置
                    d. 支持一条消息发送给多个接受者
                    e. 消息的异步处理  
            (2) 分布式 Actor 框架
```
### 数据编码及演化总结
```shell
    1. 许多服务需要支持滚动升级，即每次将新版本的服务逐步部署到几个节点，而不是同时部署到所有节点。该滚动升级允许在不停机的情况下
    　　发布新版本的服务（因此鼓励频繁地发布小版本而不是大版本），并降低部署风险（允许错误版本在影响大
       量用户之前检测井回攘）。这些特性有利于应用程序的模化和更改。所以一个系统内存在不同版本的服务，那么该服务就
       必须支持向前兼容和向后兼容．
```
