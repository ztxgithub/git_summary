
- 什么是“引用”？申明和使用“引用”要注意哪些问题？

``` c++

    引用就是目标变量的“别名”(alias),对引用的操作将会直接影响目标变量的值.申明一个引用的时候,一定要进行初始化.声明完引用后
      不能将该引用作为其他变量的引用.引用本身不是一个数据类型,所以它是不占存储单元的,不能建立数组的引用.这也是与指针的区别.
	
```

- 将“引用”作为函数参数有哪些特点？

``` c++

    使用引用传递函数的参数,在内存中是不会对实参进行拷贝,它是直接对实参操作,而用指针进行参数传递,虽然也能修改值,但是它要
    以这个值的地址传进来,而且也要拷贝一份地址的值传到函数中.
	
```

- “引用”与多态的关系

``` c++

    引用是除指针外另一个可以产生多态效果的手段.一个基类的引用可以指向它的派生类实例.
    
    Class A; 
    Class B : Class A
    {
    　　// ...
    }; 
    B b;
    A &ref_value = b;
	
```

- 引用的其他方面

``` c++

    1.不能返回局部变量的引用
    2.不提倡返回函数内部new分配的内存的引用.
        string& foo()
        {
        string* str = new string("abc");
        return *str; 
        }
        
        string str = foo(); //错误的,显然new生成的这块内存将无法释放。
        string str = "hello" + foo();  //错误的
        
        正确的做法:
            string& tmp = foo();
            string str = tmp; 
            delete &tmp;
```

-  .h头文件中的ifndef/define/endif 的作用？

``` c++

    防止该头文件被重复引用.
	
```

- 在C++程序中调用被C 编译器编译后的函数，为什么要加extern “C”？

``` c++

    extern声明的函数和变量可以在本模块或其它模块中使用.
    extern "C"是连接申明(linkage declaration),被extern "C"修饰的变量和函数是按照C语言方式编译和连接的,
	
```

- 函数在c编译器和c++编译器区别

``` c++

    void foo( int x, int y );
    如果用c编译器编译的话,在符号库中的名字为_foo,而用c++编译器编译的话,则在符号库中的名字为_foo_int_int,
    它包含了函数名,函数参数数量及类型信息.C++就是靠这种机制来实现函数重载的.
	
```

- 面向对象的三个基本特征

``` c++

    1.封装：将客观事物抽象成类,每个类对自身的数据和方法实行.
    2.继承: 可以让某个类型的对象获得另一个类型的对象的属性的方法.
    3.多态：系统能够在运行时,能够根据其类型确定调用哪个重载的成员函数的能力.
	
```

- 重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？

``` c++

    1.重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）
    2.重写：是指子类重新定义父类虚函数的方法.它和多态有关,即运行时动态得调用子类的函数.
	
```

- 类成员函数隐藏

``` c++

    1.如果派生类的函数与基类的函数同名,但是参数不同.不论有无virtual关键字,基类的函数将被隐藏（注意别与重载混淆）。
    2.如果派生类的函数与基类的函数同名,并且参数也相同,但是基类函数没有virtual 关键字.基类的函数被隐藏（注意别与覆盖混淆）
	
```

- 多态的作用？

``` c++

    1.隐藏实现细节,使得代码能够模块化；扩展代码模块,实现代码重用；
    2.接口重用:在运行时能够准确的运行对应派生类的函数.
	
```

- New delete 与malloc free 的联系与区别?

``` c++
    它们都是在堆(heap)上进行动态的内存操作,用malloc函数需要指定内存分配的字节数并且不能初始化对象,而
    new 会自动调用对象的构造函数.delete 会调用对象的析构函数,而free 不会调用对象的destructor
	
```

- 有哪几种情况只能用intializationlist 而不能用assignment?

``` c++
    当类中含有const,reference 成员变量,基类的构造函数都需要初始化表。
	
```

- main 函数执行以前,还会执行什么代码？

``` c++
    全局对象的构造函数会在main 函数之前执行,为malloc分配必要的资源,等等.
	
```

- 描述内存分配方式以及它们的区别?

``` c++
    1.从静态存储区域分配,内存在程序编译完成后就已经被分配完成,像static,全局变量
    2.在栈上创建,函数内的局部变量一样.
    3.在堆上创建,像malloc函数
    4.代码区
	
```

- 当一个类A 中没有任何成员变量与成员函数,这时sizeof(A)的值是多少

``` c++
    一个空类对象的大小是1byte.这是被编译器安插进去的一个字节,这样就使得这个空类的两个实例得以在内存中配置独一无二的地址.
	
```

- 比较C++中的4种类型转换方式

``` c++
    1.static_cast 
        在基本数据类型的类型转换,如把int转换为float,
        如：int i；
           float f；
           f=（float）i；或者
           f=static_cast<float>(i);
           
    2.const_cast
        用于取出const属性,把const类型的指针变为非const类型的指针,
        如：const int *fun(int x,int y){}
        　　int *ptr=const_cast<int *>(fun(2.3))
        
    3.dynamic_cast:
        该转换符用于将一个指向派生类的基类指针或引用转换为派生类的指针或引用,dynamic_cast转换符只能用于含有虚函数的类,
        如果转化的是类的指针,则可以通过判断是否为NULL来确定是否转化成功.
```

- 请说出const与#define 相比，有何优点？

``` c++
     const常量有数据类型,而宏常量没有数据类型.编译器可以对前者进行类型安全检查,而对后者只进行字符替换
```

- 简述数组与指针的区别

``` c++
     1.修改内容上的差别
       char a[] = “hello”;
       a[0] = ‘X’;
       char *p = “world”; // 注意p 指向常量字符串
       p[0] = ‘X’; // 编译器不能发现该错误,运行时错误
       
     2. 
        int a[10];
        a = a + 10; //错误的
        
     3.用sizeof 可以计算出数组的容量（字节数）,sizeof(p),p 为指针得到的是一个指针变量的字节数,
        而不是p 所指的内存容量
```

