# HTTP 概要

``` shell
    1.URI概念(Uniform Resource Identifier)：统一资源标识符,是一个用于标识某一互联网资源名称的字符串,URI的最常见的形式是
    统一资源定位符（URL）,经常指定为非正式的网址. URI可被视为定位符（URL）,名称（URN）或两者兼备.
    统一资源名（URN）如同一个人的名称,而统一资源定位符（URL）代表一个人的住址。换言之,URN定义某事物的身份,而URL提供查找该事物的方法.
    在类Unix操作系统中,一个典型的URL地址可能是一个文件目录,例如file:///home/username/RomeoAndJuliet.pdf。该URL标识出存储于
    本地硬盘中的电子书文件。
    
    通用URI的格式如下：
        scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
        
                        hierarchical part
            ┌───────────────────┴─────────────────────┐
                        authority               path
            ┌───────────────┴───────────────┐┌───┴────┐
      abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1
      └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘
    scheme  user information     host     port                  query         fragment
    
    scheme:协议（或称为服务方式）web服务器中通常用的就是HTTP和HTTPS，但它还可以是gopher、wais、ftp、mailto
    
    path?query_string#anchor就是我们上面说的第三部分,path指定资源在服务器上的路径（注意：像这种archive/2010/05/18/1738301.html，
    不一定就是web服务器上的绝对路径，而是经过URL重写之后的路径，但不管怎么样说，它还是唯一标识了资源在服务器上的路径）
    后面的query_string包含传递给web应用程序（如CGI）的数据.查询字符串以键/值对的形式,并且每个键值对之间用&隔开,
    如userId=skynet&password=123456；最后当使用HTTP，#anchor表示web页面的某一个部分。
    
    2.web服务器
        web服务器的主要功能就是传送web页面给clients.这意味着,传送HTML文档和其它包含在文档中的内容,
        诸如images、style sheets、JavaScripts.client通常是一个web浏览器或web爬虫,使用HTTP发起一个指定资源的请求,
        web服务器用指定的内容响应请求,或当不能做指定请求时返回一个错误消息.请求的资源通常是web服务器的辅助存储器上的一个实际文件，
        但是这不是必须，取决于web服务器的实现.
        虽然web服务器的主要功能是提供内容，但一个完整的HTTP实现还包括接收来自client的内容。这个功能用于提交web表单,包括上载文件.
        
    3.web服务器怎样提供服务
        当用户通过点击一个超链接或在浏览器的地址栏中输入一个URL浏览一个web站点。但是同一个站点如何同时在网络上的不同计算机上显示的呢？
        以我博客的主页为例,当你在浏览器的地址栏中输入http://home.cnblogs.com/skynet/时,通过一个Internet连接,通过将域名转换为ip地址,
        然后定位到博客园服务器,你的浏览器初始化一个与博客园web服务器的连接.web服务器上存储了我的博客里所有的资源，
        如我写的每篇文章、文章中用到的图片、还有博客模板中用到的css、脚本等等。
        一旦连接建立，浏览器使用HTTP从web服务器请求数据,服务器传输数据给你的浏览器。浏览器接着转换和格式化数据显示到你的浏览器中。
        类似的，web服务器可以同时发生文件到多个client，允许多个client同时浏览同一页面.
        
    4.客户端如何唯一标识web服务器的资源
        
    5.一个Web服务器也被称为HTTP服务器,它通过HTTP协议与客户端通信.
      这个客户端通常指的是Web浏览器(其实手机端客户端内部也是浏览器实现的 
      需要注意的是客户机与服务器之间的通信是非持久连接的,也就是当服务器发送了应答后就与客户机断开连接,等待下一次请求
```

## HTTP协议详解

``` shell
    1.相关概念
        (1) HTTP是一种让Web服务器与浏览器(客户端)通过Internet发送与接收数据的协议,它建立在TCP协议之上,
            一般采用TCP的80端口.在HTTP中,客户端总是通过建立一个连接与发送一个HTTP请求来发起一个事务。
            服务器不能主动去与客户端联系,也不能给客户端发出一个回调连接.客户端与服务器端都可以提前中断一个连接。
            例如,当浏览器下载一个文件时,你可以通过点击“停止”键来中断文件的下载,关闭与服务器的HTTP连接
            
        (2) HTTP协议是无状态的,同一个客户端的这次请求和上次请求是没有对应关系,对HTTP服务器来说,
            它并不知道这两个请求是否来自同一个客户端.为了解决这个问题, Web程序引入了Cookie机制来维护连接的可持续状态
            
    2.HTTP请求包（浏览器信息）
        Request包分为3部分,第一部分叫Request line（请求行）, 第二部分叫Request header（请求头）,
        第三部分是body（主体）. header和body之间有个空行
        
        请求包的例子所示:
                GET /domains/example/ HTTP/1.1		//请求行: 请求方法 请求URI HTTP协议/协议版本
                Host：www.iana.org				//服务端的主机名
                //浏览器信息
                User-Agent：Mozilla/5.0 (Windows NT 6.1) 
                           AppleWebKit/537.4 (KHTML, like Gecko)
                           Chrome/22.0.1229.94 
                           Safari/537.4			
                Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8	//客户端能接收的mine
                Accept-Encoding：gzip,deflate,sdch		//是否支持流压缩
                Accept-Charset：UTF-8,*;q=0.5		//客户端字符编码集
                //空行,用于分割请求头和消息体
                //消息体,请求资源参数,例如POST传递的参数
            
        HTTP协议定义了很多与服务器交互的请求方法,最基本的有4种,分别是GET,POST,PUT,DELETE.
        一个URL地址用于描述一个网络上的资源,而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查,增,改,删4个操作。
        我们最常见的就是GET和POST了.GET一般用于获取/查询资源信息，而POST一般用于更新资源信息
        
        GET和POST的区别:
            A. GET请求消息体为空,POST请求带有消息体。
            B. GET提交的数据会放在URL之后,以"?"分割URL和传输数据,参数之间以&相连,如EditPosts.aspx?name=test1&id=123456.
               POST方法是把提交的数据放在HTTP包的body中。
            C. GET提交的数据大小有限制（因为浏览器对URL的长度有限制）,而POST方法提交的数据没有限制。
            D. GET方式提交数据,会带来安全问题,比如一个登录页面,通过GET方式提交数据时,用户名和密码将出现在URL上,
               如果页面可以被缓存或者其他人可以访问这台机器,就可以从历史记录获得该用户的账号和密码.
               
    3.HTTP响应包（服务器信息）
        HTTP的response包:
            HTTP/1.1 200 OK						//状态行
            Server: nginx/1.0.8					//服务器使用的WEB软件名及版本
            Date:Date: Tue, 30 Oct 2012 04:14:25 GMT		//发送时间
            Content-Type: text/html				//服务器发送信息的类型,
            Transfer-Encoding: chunked			//表示发送HTTP包是分段发的
            Connection: keep-alive				//保持连接状态
            Content-Length: 90					//主体内容长度
            //空行 用来分割消息头和主体
            <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"... //消息体
            
            
        Response包中的第一行叫做状态行,由HTTP协议版本号,状态码,状态消息 三部分组成.
        
        Content-Type: 浏览器就是依靠Content-Type来判断响应的内容是网页还是图片，是视频还是音乐
        
        状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.HTTP/1.1协议中定义了5类状态码,
        状态码由三位数字组成,
        第一个数字定义了响应的类别
            1XX 提示信息 - 表示请求已被成功接收，继续处理
            2XX 成功 - 表示请求已被成功接收，理解，接受
                200：请求被成功处理
            3XX 重定向 - 要完成请求必须进行更进一步的处理
                301/302 : 永久性重定向/临时性重定向
                          (1) 当我建了一个网站之后，我想将它整个url进行改变，如重新申请了一个域名，我又
                              希望原来的用户用之前的域名不受影响，可以做一个重定向,当它以原来的域名进行
                              申请时，则可以重定向到新的域名下面。
                          (2) 当我访问某一个页面,比如个人中心页面的时候,用户在 未登录的状态 访问个人中心
                              页面,这个时候可以临时性的重定向到登陆页面。
            4XX 客户端错误 - 请求有语法错误或请求无法实现
                403：没有权限访问
                     
                404：表示没有对应的资源
            5XX 服务器端错误 - 服务器未能实现合法的请求
                500：服务器错误
                503：服务器停机或正在维护
         
            
    4.HTTP协议是无状态的和Connection: keep-alive的区别
        无状态是指协议对于事务处理没有记忆能力,服务器不知道客户端是什么状态.从另一方面讲,
        打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系.
        
        HTTP是一个无状态的面向连接的协议,无状态不代表HTTP不能保持TCP连接,更不能代表HTTP使用的是UDP协议（面对无连接）
        
        从HTTP/1.1起,默认都开启了Keep-Alive保持连接特性,简单地说,当一个网页打开完成后,
        客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭,如果客户端再次访问这个服务器上的网页,
        会继续使用这一条已经建立的TCP连接。
        
        Keep-Alive不会永久保持连接,它有一个保持时间,可以在不同服务器软件（如Apache）中设置这个时间
```

## session和数据存储

``` shell
    1.概念
        A.
         Web 开发中一个很重要的议题就是如何做好用户的整个浏览过程的控制,因为 HTTP 协议是无状态的,
         所以用户的每一次请求都是无状态的,我们不知道在整个 Web 操作过程中哪些连接与该用户有关,
         我们应该如何来解决这个问题呢？Web 里面经典的解决方案是 cookie 和 session ,cookie 机制是一种客户端机制.
         而 session 机制是一种服务器端的机制,服务器使用一种类似于散列表的结构来保存信息,
         每一个网站访客都会被分配给一个唯一的标志符,即 sessionID,它的存放形式无非两种:
         要么经过 url 传递,要么保存在客户端的 cookies 里.当然,你也可以将 Session 保存到数据库里,
         这样会更安全,但效率方面会有所下降.
         
        B.
            考虑这样一个问题：
                如何抓取一个访问受限的网页？如新浪微博好友的主页,个人微博页面等。
                显然,通过浏览器,我们可以手动输入用户名和密码来访问页面,而所谓的“抓取”,
                其实就是使用程序来模拟完成同样的工作,因此我们需要了解“登陆”过程中到底发生了什么
                
                当用户来到微博登陆页面,输入用户名和密码之后点击“登录”后浏览器将认证信息 POST 给远端的服务器,
                服务器执行验证逻辑,如果验证通过,则浏览器会跳转到登录用户的微博首页,在登录成功后,
                服务器如何验证我们对其他受限制页面的访问呢？因为 HTTP 协议是无状态的,
                所以很显然服务器不可能知道我们已经在上一次的 HTTP 请求中通过了验证.当然,
                最简单的解决方案就是所有的请求里面都带上用户名和密码,这样虽然可行,但大大加重了服务器的负担
                （对于每个 request 都需要到数据库验证）,也大大降低了用户体验(每个页面都需要重新输入用户名密码,
                每个页面都带有登录表单).既然直接在请求中带上用户名与密码不可行,那么就只有在服务器或客户端保存一些
                类似的可以代表身份的信息了,所以就有了 cookie 与 session.
                
    2.cookie
        简而言之就是在本地计算机保存一些用户操作的历史信息（当然包括登录信息）,
        并在用户再次访问该站点时浏览器通过 HTTP 协议将本地 cookie 内容发送给服务器,从而完成验证，或继续上一步操作.
        这样才能达到有状态的请求.
        
        Cookie 是由浏览器维持的,存储在客户端的一小段文本信息,伴随着用户请求和页面在Web服务器和浏览器之间传递.
        用户每次访问站点时,Web应用程序都可以读取cookie包含的信息.浏览器设置里面有cookie隐私数据选项,打开它，
        可以看到很多已访问网站的cookies
        
        cookie是有时间限制的,根据生命期不同分成两种：会话cookie和持久cookie
        
        如果不设置过期时间,则表示这个cookie的生命周期为从创建到浏览器关闭为止,只要关闭浏览器窗口,cookie就消失了.
        这种生命期为浏览会话期的cookie被称为会话cookie,会话cookie一般不保存在硬盘上而是保存在内存里。
        
        如果设置了过期时间(setMaxAge(606024)),浏览器就会把cookie保存到硬盘上,关闭后再次打开浏览器,
        这些cookie依然有效直到超过设定的过期时间.存储在硬盘上的cookie可以在不同的浏览器进程间共享,
        比如两个IE窗口,而对于保存在内存的cookie,不同的浏览器有不同的处理方式。 
        
        在python中
               I. cookie是浏览器本地存储的信息,它的存储方式是类似python的dict,其在浏览器中是以文本形式存储,而浏览器会对
                 其进行解析,在访问某个网站时,在google浏览器中按F12,在Application选项中找到对应的cookies,它是以key-value
                 保存的,每一个域名在都有对应的cookies,而不用域名的cookies不能交叉共用
            
               II.cookie浏览器流程(一般是cookies(针对浏览器)和session(针对服务器)一起使用)
                     用户                              服务器
                                 请求1
                     (1)   --------------------->       (2)
                          
                            发现没有id,则分配一个id=1
                     (4)   <----------------------      (3)
                     
                           请求2  带上cookies中的 id =1
                     (5)   ---------------------->      (6)
                     
                     
                     
                   说明:
                    
                        A:  在(4)中浏览器收到了服务器的响应报文里有 id 标识,则将 id 保存在 cookies中,并保存到本地磁盘上,使得
                            重新打开浏览器,在 cookies 中还有对应的id
                            
                        B: 在(6)中,服务器看到对应的cookies的 id == 1 , 就知道是用户A发过来的请求
                        
               III.
                  每次浏览器请求服务器时,都要发送 之前服务器给浏览器的信息， 以完成用户信息的保存
                  
        cookies的缺点:
            cookies 中保存了所有用户相关的信息,包括用户名和密码,可以通过对浏览器的 cookies 的分析解析出 用户名和密码,存在
            安全隐患,这时候得使用 session.
                
            
        
    3.session
        简而言之就是在服务器上保存用户操作的历史信息.服务器使用session id来标识session,
        session id由服务器负责产生,保证随机性与唯一性,相当于一个随机密钥,
        避免在握手或传输中暴露用户真实密码.但该方式下,仍然需要将发送请求的客户端与session进行对应,
        所以可以借助cookie机制来获取客户端的标识（即session id）,也可以通过GET方式将session id提交给服务器.
        
        session是指有始有终的一系列动作/消息,比如打电话是从拿起电话拨号到挂断电话这中间的一系列过程可以称之为一个session.
        然而当session一词与网络协议相关联时,它又往往隐含了“面向连接”和/或“保持状态”这样两个含义.
        
        session在Web开发环境下的语义又有了新的扩展,它的含义是指一类用来在客户端与服务器端之间保持状态的解决方案.
        有时候Session也用来指这种解决方案的存储结构。
        
        session机制是一种服务器端的机制,服务器使用一种类似于散列表的结构(也可能就是使用散列表)来保存信息。
        
        但程序需要为某个客户端的请求创建一个session的时候,服务器首先检查这个客户端的请求里是否包含了
        一个session标识－称为session id,如果已经包含一个session id则说明以前已经为此客户创建过session,
        服务器就按照session id把这个session检索出来使用(如果检索不到，可能会新建一个,
        这种情况可能出现在服务端已经删除了该用户对应的session对象,但用户人为得在请求的URL后面附加上一个JSESSION的参数)。
        如果客户请求不包含session id,则为此客户创建一个session并且同时生成一个与此session相关联的session id,
        这个session id将在本次响应中返回给客户端保存.
        
        session机制本身并不复杂,然而其实现和配置上的灵活性却使得具体情况复杂多变.
        这也要求我们不能把仅仅某一次的经验或者某一个浏览器，服务器的经验当作普遍适用的。
        
        实际例子：
            在服务器端的数据库中保存有session的相关信息,比如 session_key(服务器给浏览器的session_id), 
            session_data(将用户信息,包括用户名和密码进行加密后得到的数据) , expire_date(该session的过期时间).
            这样以后浏览器每次去请求服务器都带有session_id,这样浏览器每次请求就不需要带用户名和密码,而服务器则通过这个
            session_id就可以判断是哪个用户。
```

## HTTP Authorization

```shell
    (1) Basic Auth 认证
            基本认证(Basic access authentication)是一种用来允许网页浏览器或其他客户端程序在请求时提供用户名和口令形式的
            身份凭证的一种登录验证方式
            
            报文头headers
            Authorization: Basic YWRtaW46YWRtaW4= //Authorization: "Basic username:password的base64加密字符串
            
            http auth的过程:
                1.客户端发送http请求
                2.服务器发现配置了http auth,于是检查request里面有没有"Authorization"的http header
                2.如果有，则判断Authorization里面的内容是否在用户列表里面,
                   Authorization header的典型数据为"Authorization: Basic jdhaHY0="，其中Basic表示基础认证,
                   jdhaHY0=是base64编码的"user:passwd"字符串。如果没有，或者用户密码不对,则返回http code 401页面给客户端.
                3. 标准的http浏览器在收到401页面之后,应该弹出一个对话框让用户输入帐号密码；
                   并在用户点确认的时候再次发出请求，这次请求里面将带上Authorization header
```