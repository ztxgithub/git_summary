# 服务器性能优化

## 基础知识

- 网络带宽

``` shell

    单位是bps(bit per second)
    分布式：一个业务分拆多个子业务,部署在不同的服务器上
    集群：同一个业务,部署在多个服务器上
    
			
```

## 系统性能定义

     系统性能包括Throughput(吞吐量)和Latency(系统延时),
     Latency越好，能支持的Throughput就会越高.因为Latency短说明处理速度快，于是就可以处理更多的请求。

### Throughput(吞吐量)
    
``` shell

    吞吐量代表了一段时间内的网络上传输的数据量的总和
    吞吐率则代表单位时间内的网络传输的数据量,同时也可以理解为单位时间内要处理客户的请求数量.吞吐率单位一般用byte/s.
    		
```

### Latency(系统延时)

``` shell

    Latency(系统延时)代表服务器处理请求的能力,和TPS(Transaction Per second)的概念是一致的.
    		
```

### 性能判断

- CPU利用率

``` shell

    如果CPU利用率不高,但是系统的Throughput和Latency上不去了,这说明我们的程序并没有忙于计算,而是忙于别的一些事，比如IO.
    CPU的利用率还要看内核态的和用户态的,内核态的一上去了,整个系统的性能就下来了.而对于多核CPU来说,CPU 0 是相当关键的,
    如果CPU 0的负载高,那么会影响其它核的性能,因为CPU各核间是需要有调度的,这靠CPU0完成
    
    cpu低而负载高说明等待磁盘I/O完成的进程过多,就会导致队列长度过大,这样就体现到负载过大了,
    但实际是此时cpu被分配去执行别的任务或空闲.
    
    场景一：磁盘读写请求过多就会导致大量I/O等待
    
    场景二：MySQL中存在没有索引的语句或存在死锁等情况
                MySQL的数据是存储在硬盘中,如果需要进行sql查询,需要先把数据从磁盘加载到内存中.
                当在数据特别大的时候,如果执行的sql语句没有索引,就会造成扫描表的行数过大导致I/O阻塞,或者是语句中存在死锁,
                也会造成I/O阻塞,从而导致不可中断睡眠进程过多,导致负载过大.
                具体解决方法可以在MySQL中运行show full processlist命令查看线程等待情况,把其中的语句拿出来进行优化.
                
    场景三：访问第三方api接口
              如果我们访问第三方http api,例如接口的响应时间很慢，readTimeout=2000ms，在高并发的情况下，很多线程都被中断等待api的网络IO。导致cpu使用率很低，但是load很高。
    		
```


- IO使用情况

``` shell

    IO使用情况和CPU使用情况一般是反着来的,CPU利用率高则IO不大.
    1.磁盘文件IO 2.网络IO 3.内存使用情况
    		
```

- 业务

``` shell

    通常一个小小的业务的调整可以很大程度得减缓服务器的压力
    1.在高并发情况下保持数据一致性是一个瓶颈,单单只是静态的请求没有问题,但请求引发的一系列业务操作就有压力,
    常用的方法:将数据请求不进行立刻处理,采用异步的方式,数据先保存,再不同的线程中根据不同的业务进行处理(水平扩展)
    
			
```

- 数据库

``` shell

    数据分区
        1.可以按照逻辑分类,将一张表拆成多张有一样的字段但是不同种类的表,这样可以提高查询的速度.	
```

- 负载均衡

``` shell
       1. 需要有任务调度(分配)系统,监控各个服务器的负载情况,调度系统需要考虑到cpu情况,磁盘IO,内存使用率,并发高,内存换页率
        等情况,任务调度系统还要任务队列,不能丢任务,要持久化,支持批量的方式分配给计算服务器.需要一些如Live-Standby或是
        failover等高可用性的技术防止任务调度系统崩溃.
        
       2.通过抢占式的方式进行负载均衡,由下游的计算服务器申请向任务服务器拿任务.
       
```

- 批量处理

``` shell
    将相同的请求进行批量的处理,批量处理为解决数据库操作以及磁盘IO一次性太频繁.比如,大家同时购买同一个商品,
    没有必要你买一个我就写一次数据库,完全可以收集到一定数量的请求.一次操作.
    批量处理的系统一般都会设置上两个阀值,一个是作业量,另一个是timeout,只要有一个条件满足,就会开始提交处理.
       
```

- 水平扩展

``` shell
    系统设计一定要很容易得进行水平扩展,当系统的性能有问题只要增加服务器个数就行了.
       
```

## 性能优化方法

- 分而治之和预处理

``` shell
    以前有一个程序为了生成月报表,每次都需要计算很长的时间,可以通过增量式的方法:每天都把当天的数据计算好了后和前一天的报表合并,
    这样可以大大的节省计算时间,体现了分而治之（SQL语句在大数据量面前性能成级数性下降）,
    这种分而治之的思路在大数据面前对性能有很帮助,就像merge排序一样.SQL语句和数据库的性能优化也是这一策略,
    如：使用嵌套式的Select而不是笛卡尔积的Select，使用视图，等等。
```

- 代码调优

``` shell
    1.字符串操作
        字符串操作如strcpy,strcat等这些是很费系统性能的,能用整型最好用整型.例如状态码由字符串全改成整型,然后用位操作查状态,
        因为有一个每秒钟被调用了150K次的函数里面有三处需要检查状态,经过改善以后，整个系统的性能上升了30%左右.
        
    2. 内存分配
        malloc/realloc/calloc这样的系统调非常耗时,尤其是当内存出现碎片的时候.可以通过内存池来解决这一类的问题
        比如线程池,连接池等。池化技术对于一些短作业来说（如http服务)相当相当的有效.
        这项技术可以减少链接建立，线程创建的开销，从而提高性能
        
    3.网络性能
        select系统调用只支持上限1024个链接,poll其可以突破1024的限制,但是select和poll本质上是使用的轮询机制,
        轮询机制在链接多的时候性能很差,因主是O(n)的算法,所以epoll出现了,epoll是操作系统内核支持的,
        仅当在链接活跃时,操作系统才会callback,这是由操作系统通知触发的，
        但其只有Linux Kernel 2.6以后才支持（准确说是2.5.44中引入的）.
        当然，如果所有的链接都是活跃的，过多的使用epoll_ctl可能会比轮询的方式还影响性能，不过影响的不大.
        
        gethostbyaddr/gethostbyname这个函数可能会相当的费时,因为其要到网络上去找域名,
        因为DNS的递归查询,会导致严重超时,对此你可以通过配置hosts文件来加快速度,或是自己在内存中管理对应表.
        在程序启动时查好,而不要在运行时每次都查.在多线程下,gethostbyname会一个更严重的问题,
        就是如果有一个线程的gethostbyname发生阻塞,其它线程都会在gethostbyname处发生阻塞,可以用gethostbyname_r()
     
    4.数据库性能
        全表检索: 1.可以通过分表,把记录数降下来. 2.建索引
        不要select *,而是明确指出各个字段,如果有多个表，一定要在字段名前加上表名,不要让引擎去算.
        不要用Having,因为其要遍历所有的记录.性能差得不能再差.
```